### C语言自定义类型

​	C语言有许多自定义类型，比如数组，指针，结构体等等，相信大家对数组和指针已经可以说是熟能生巧了，我们今天重点讨论一下其他的几种自定义数据类型。

​	今天我们要讨论的是：结构体、枚举、联合体以及位段，接下来让我们一一了解。

#### 结构体

##### 结构体的基本概念

​	什么是结构体呢？结构体就是一系列不同元素的集合，可以用这些元素描述一类具有相同属性的事物。

​	那么如何【声明结构体】和【定义结构体变量】呢？

```c
struct tag{			//tag为结构体名，可以自行设置
    member-list;		//成员列表
}Tag1;			//当struct前没有typedef时，这种写法是定义了一个结构体变量
	
struct tag Tag1 = {}; 	//定义一个tag结构体类型的变量Tag1
```

​	不知道大家有木有发现，在定义变量的时候很麻烦呢？每次定义都要加一个struct，有木有很烦呢？这里我们有两种方法：

```c
typedef struct tag tag_t;		//1. 可以利用typedef对结构体类型进行重命名，但是一般不这样做。

typedef struct tag{			//2. 在定义时，我们直接进行重命名，推荐使用这种
    member-list;		
}tag_t , *ptag_t;

tag_t Tag1;		//定义一个结构体变量
ptag_t ptag;	//定义一个结构体指针变量
```

##### 匿名结构体

​	什么时匿名结构体呢？简而言之就是没有 Tag 的结构体，它的变量定义只能在声明时定义，例如：

```c
struct {			//结构体声明
    int id;
    int age;
    char name[32];
}p[100];			//变量定义
```

##### 结构体的自引用

​	结构体内可以是整型，数组，指针，其他结构体，那么结构体里可以放自己吗？看一个简单的例子：

```c
typedef struct Stu{
    int num;
    char name[32];
    Stu_t Stu_ret;		//这样可以不？
}Stu_t, *pStu_t;
```

​	我们知道，要用一个类型，定义一个变量，那么这种类型所占的大小必须确定。那么这个结构体的大小可以计算出来吗？当然不能，当我们用这个定义变量时，会不停的递归，因而不能确定这个结构体的大小，所以不能定义。还有一个问题是，我们在定义的过程中，程序编译到 Stu_t Stu_ret 时，Stu_t这个类型还没有被完全定义出来，所以一般编译器都会报，未定义的类型。这是笔者在gcc编译环境下测试结果：

```c
test.c:6:2: error: unknown type name ‘Stu_t’
  Stu_t Stu_ret;
  ^~~~~
```

​	但是如果我们非要这样做呢？其实我们可以这样写：

```c
typedef struct Stu{
    int num;
    char name[32];
    struct Stu_t* Stu_ret;		//定义一个结构体指针	注意在此不能使用pStu_t 因为还没有定义出来
}Stu_t, *pStu_t;				
```

​	这个就叫做结构体的自引用，不知道大家get到了没？

##### 结构体的内存对齐

​	我们知道，定义一个变量，需要一定的空间，比如定义一个Int型的变量，那么变量的大小就为4个字节，double为8字节，数组为数组类型大小乘以元素个数，那么我们的结构体的大小如何去算呢？比如下面这个：

```c
struct Stu{
    int id;
    char name[32];
    char subject[10];
    double grade;
};

int main(){
    printf("%d\n", sizeof(struct Stu));
    return 0;
}
```

​	结果是多少呢？是55吗？答案是64，是不是很惊讶呢？我们结构体的存储不是向整型数字指针那样简单的，结构体在存储中还要考虑一个叫做内存对齐的东东。

​	在这之前，先买个关子，那么为什么要内存对其呢？

​	1 . 平台原因(移植原因)： 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

​	2 . 性能原因： 数据结构(尤其是栈)应该尽可能地在自然边界上对齐。 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问

​	那么如何进行内存对其呢？这里有4条基本原则：

​	1 . 第一个成员在与结构体变量偏移量为0的地址处。

​	2 . 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
​		对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。

​		VS中默认的值为8   Linux中的默认值为4

​	3 . 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。 	

​	4 . 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是
所有最大对齐数（含嵌套结构体的对齐数）的整数倍 	

​	知道呢这些理论我们再来看一下上面的那个问题，为什么是64呢？

```c
struct Stu{
    char Sex;			// 1  < 4 对齐数为1
    int id;				// 4  = 4 对齐数为4
    char name[32];		// 1  < 4 对齐数为1
    char subject[10];	// 1  < 4 对齐数为1
    double grade;		// 8  > 4 对齐数为8
};						// 结构体整体对齐数为8
```

所以，最后的内存结构图是这样的，一个格子是一个字节

![](E:\MyCode\MyStudyNote\C\内存对齐.jpg)

​	如若还不明白，可以留言私信。

#### 枚举

​	枚举顾名思义就是一一列举，把可能的取值一一列举。比如彩虹的颜色，性别，星期一到星期天诸如此类的。

​	如何定义声明枚举类型和如何定义枚举变量：

```c
enum Color{			//颜色
	RED=1,			//这些可能取值都是有值的
	GREEN=2,		//默认从0开始，一次递增1
	BLUE=4			//当然在定义的时候也可以赋初值。
};
enum Color clr = GREEN;		//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。
```

​	{}中的内容是枚举类型的可能取值，也叫枚举常量 。 	

​	我们可以使用 #define 定义常量，为什么非要使用枚举？ 枚举的优点： 

​	1 . 增加代码的可读性和可维护性

​	2 . 和#define定义的标识符比较枚举有类型检查，更加严谨。

​	3 . 防止了命名污染（封装）

​	4 . 便于调试

​	5 . 使用方便，一次可以定义多个常量 

#### 联合体（共用体）

​	联合也是一种特殊的自定义类型 这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）。

```c
//联合类型的声明
union Un{
	char c;
	int i;
};
//联合变量的定义
union Un un;
//计算连个变量的大小
printf("%d\n", sizeof(un));
```

​	联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为联合至少得
有能力保存最大的那个成员）。

​	联合体的地址和所有成员的地址是一样的 。

​	联合体大小的计算

​	1 . 联合的大小至少是最大成员的大小。
​	2 . 当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍 	

#### 位段

​	位段的声明和结构是类似的，有两个不同： 

​		1 . 位段的成员必须是 int、unsigned int 或signed int 。 

​		2 . 位段的成员名后边有一个冒号和一个数字。 

```c
struct A
{
	int _a:2;	//:数字的意思是，_a变量占2 个 bit位
	int _b:5;	
	int _c:10;
	int _d:30;
};
printf("%d\n", sizeof(struct A));
```

​	那么位段A的大小为多少呢？是4个字节吗？答案当然不是，答案是2个字节。

​	其实位段的大小在不同编译环境下的大小可能不是一样的， 和编译器有关。

​	**位段的内存分配**

​	1 . 位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型

​	2 . 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。

​	3 . 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。 

​	**位段的跨平台问题**

​	1 . int 位段被当成有符号数还是无符号数是不确定的。

 	2 . 位段中最大位的数目不能确定。16位机器最大16，32位机器最大32，写成27，在16位机器会出问
题。

​	3 . 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。

​	4 . 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的
位还是利用，这是不确定的。

​	跟结构体相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。 

​	位段只是了解，现阶段我们可能遇不到，在网络协议中，IP数据报的报头就是用的位段。

#### 总结

​	今天我们主要讨论了，结构体  、 枚举、联合以及位段 ， 在自定义数据类型中，我们只要掌握好数组，指针，以及结构体就OK了， 联合、枚举、位段，只要以后遇到认识就行。

​	好了，今天我们就讨论到这里。



​	由于本人才疏学浅，若有疏忽还望不吝赐教。

​	@YeLing0119