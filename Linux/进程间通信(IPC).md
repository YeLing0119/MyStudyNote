## 程间通信（IPC）

#### 为什么要进程通信？
> 为什么要进程间通信：大项目的模块化，协同运行
1. 数据传输
    > 一个进程需要将它的数据发送到另一个进程
2. 资源共享
    > 多个进程之间共享同样的资源
3. 通知事件
    > 一个进程要向另一个程序发送通知消息，通知它们发生了某种事件，比如子进程终止时要通知父进程
4. 进程控制
    > 有些进程希望完全控制另一个进程的执行（比如 ： DEGUG），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够知道他们状态的改变。
> 为什么进程通信需要操作系统提供接口：因为独立性
- 操作系统如何能够让进程之进行通信：给多个进程之间提供一个公共的，都能访问到的媒介
- 操作系统因为提供进程间通信的使用场景不同，因此提供的进程间通信方式也有多种，各自也有各自的特点
#### 进程间通讯的发展
1. 管道
    - 匿名
    - 命名
2. SystemV 标准
    - ​消息队列（数据传输）
    - ​共享内存（资源共享）
    - 信号量（事件通知）
3. POSIX 标准 (标准c库使用)
    - 消息队列
    - 共享内存
    - 互斥量
    - 条件变量
    - 信号量
    - 读写锁
#### 管道
- 用于在进程间传输数据资源
- 对于管道这块缓冲区的操作，和io操作使用同一套接口
- 管道的特性
    - 管道时半双工通讯(单向通讯)
    - 读写特性
        - 如果管道中没有数据，则read会阻塞，直到读取出数据
        - 如果管道中数据满了，则write会阻塞，直到有数据被读出去
        - 如果管道的所有写端都被关闭，那么读端读完管道中的数据之后，返回0
        - 如果管道的所有读端都被关闭，那么写端写入数据的时候会触发异常，退出进程
    - 管道自带同步与互斥保护操作
    - 提供字节流服务(数据传输灵活，但是有可能造成数据的粘连)
    - 生命周期随进程
    - 匿名管道:只能用于具有亲缘关系的进程
- 匿名管道  
    - 创建的缓冲区没有标识，因此**只能用于具有亲缘关系的进程间通信**，创建一个管道，返回文件描述符，这时创建一个子进程，子进程复制父进程，因此子进程也有相同的描述符指向内核相同的缓冲区，这是就可以通信了
        > ```int  pipe (int fds[2])；```

    ![](./管道.jpg)
    - 一个例子
        > [利用管道函数pipe实现进程间通讯](https://github.com/YeLing0119/MyCode/tree/master/Linux/pipe)
- 命名管道
- 同步：对临界资源操作的时序可控性
- 互斥：对临界资源在同一时间的唯一访问性
- 当对管道的读写数据大小不大于PIPE_BUF时候，将保证数据读写的原子性
#### 消息队列

1. 获取/创建消息队列
    ```c
    ​#include \<sys/msg.h\>	
    #include \<sys/ipc.h>
    int msgget(key_t key ,  // 相当于文件名
            int flags)	;	// 创建  IPC_CREAT | 0644(权限)	                    // 打开   0	
    ```
    - 返回值：消息队列的id ，相当于文件描述符
    - 查看IPC对象 
    - ipcs  -q  //查看消息队列   查看IPC对象
    - ipcrm  -Q  key   //删除指定key的消息队列  删除IPC对象
    - 系统中最多可以创建多少个消息队列?​
        - cat /proc/sys/kernel/msgmni	//最多创建个数
        - cat /proc/sys/kernel/msgmax	//一条消息最多装多少字节
	    - cat /proc/sys/kernel/msgmnb	//一个消息队列中一个消息的总字节数是多少
2. 发送消息
    ```c
    int msgsnd(int msgid , 		//msgget的返回值
    const void* msgp , 	//消息的位置		必须是类似于msgbuf的结  构体
    size_t len , 		//消息的长度		不包括type的大小
    int flag) ;			//消息的标志位
    ```
    返回值	： -1 //失败		0 //成功
    ```c
    struct msgbuff{
    long type ; 		//消息类型	必须 >= 1	必须有
    //随便			随意类型，写上自己的消息
    }	
    ```
3. 接收消息
    ```c
    ssize_t msgrcv(
        int msgid, //msgget的返回值
        void *msgp, //取出消息存放位置
        size_t msgsz, //装消息位置的大小，不包括类型
        long msgtype, //取那个类型的消息
        int msgflag //选项，一般填0，表示没有消息就在等，有了就取出来
    );
    ```
- 返回值：-1	失败   	成功实际拷贝的字节数
#### 共享内存
1. 创建或者打开共享内存
    ```c
    ​shmget(
        key_t key, //相当于文件名
        size_t size,  //共享内存的大小
        int flag   //创建IPC_CREAT|0664	打开0
    );  
    ```
- 返回值：-1  	 失败    0		成功

2. 让共享内存与本进程建立关系
    ```c
    ​void  *shmat(
        key_t key , 
        const char* shmaddr ,  //让操作系统挂载到地址空间的位置 若为NULL，这让操作系统自己选择 
        int flag    // 0
    );
    ```
- 返回值：实际挂载到虚拟地址空间的起始位置
3. 卸载掉共享内存
    `int shmdt(void * shmaddr);`	
4. 删除共享内存
    ```c
    ​int shmctl(
        key_t key , 
        int cmd , //IPC_RMID 删除共享内存
        NULL    //本来这里是个结构体，但是删除用不上，直接填NULL
    )
    ```
