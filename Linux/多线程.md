## 多线程
> 线程是什么？程序里的一个执行路线，更准确的定义是：线程是“个进   程内部的控制序列”

> 线程组 --> tgid

> tgid = 主线程的pid

> PID --> tgid

1. 线程时进程中的一个执行流，线程是cpu调度的基本单位
2. 一个进程至少一个进程，进程中至少有一个pcb
3. 进程中的线程是运行在同一个虚拟空间之上
4. 线程时进程调度的基本单位，进程是资源分配的基本单位
linux下的线程是以进程的pcb模拟的，Linux下的pcb实际上是一个个线程，因为这些pcb相较于传统的pcb更加的轻量化(因为共用同一块虚拟地址空间)，Linux下的线程也称为轻量级进程。

- 进程和线程那个好？
    - 线程的优点：因为使用同一个虚拟地址空间
      1. 线程的创建/销毁成本更加低
      2. 线程间通信更加方便
      3. 线程的切换调度成本更加低
      4. 线程的执行粒度更加细致
    - 线程的缺点
      1. 因为缺乏控制，因此编码需要注意的问题更多
      2. 稳定性低
    - 分析优缺点，视使用情况而定

- 线程控制：因为操作系统并没有提供线程控制的接口，因此大佬们就实现了一套库函数来进行线程的控制，因为线程的接口个代码都是在共享区，因此也说我们使用这套接口创建的线程时用户态的进程，但是线程在我们操作系统内部对应了一个轻量级线程作为执行调度的载体
  - 线程创建
    - pthread_create
        ```c
        int pthread_create(
            pthread_t *thread,  //输出型参数，用于获取用户态线程id
            const pthread_attr_t *attr,     //线程属性 通常置NULL
            void *(*start_routine) (void *),    // 线程的入口函数
            void *arg   //      传递给线程的参数
        );
        ```
        - 返回值： 成功 0  失败 error number
  - 线程终止
    - 终止的方式
      - return 但是主线程中，不能return 普通线程可以
      - pthread_exit 谁调用谁退出
      - pthead_cancel 取消指定的线程
  - 线程等待：等待指定线程的退出
    - 只有处于 joinable 状态，才是可以被等待的
    - 线程退出后，为了保存退出返回值，因此操作系统不会直接自定回收资源，需要其他线程等待，获取返回值，并允许操作系统回收资源，否则不等待则会造成资源的泄露
    - pthread_join：等待指定的线程退出 
        ```c
        int pthread_join(
            pthread_t tid,  // 指定的线程id 
            void **retval   // 接受返回值
        );
        ```
  - 线程的分离：设置线程的分离属性，被设置的线程退出后，将直接自动回收资源，不需要等待
    - 如果线程处于joindetach状态，则线程不能被等待
    - pthread_detach
- 线程数据的独有与共享
  - 共享
    1. 文件状态信息表
    2. 信号的处理方式
  - 独有
    1. 栈    
    2. 一组寄存器(上下文数据和程序计数器)
    3. 信号屏蔽字
    4. 调度优先级

- 线程安全：线程之间对临界资源的安全访问
    > 因为在cpu足够的情况下，多个线程的运行可能是并行的，因此对临界资源的访问，就有可能造成争抢，会造成数据的二义性

    - 因此线程安全就是讨论如何保证线程对临界资源的安全访问:
        - 使用同步与互斥解决
          - 同步：对临界的访问时序可控性
          - 互斥：对临街资源同一时间唯一访问性
    - 如何实现线程间的同步与互斥
        - 互斥锁(互斥)
          - 就是一个只有0/1的计数器
            - 1 有资源能操作
            - 0 没资源则阻塞
        - 条件变量(同步)
          - 000