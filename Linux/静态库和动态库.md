## 静态库和动态库
 - gcc的默认链接方式是动态链接
#### 1. 静态库
- ​对一系列 .o 文件的打包
- ​生成静态库的方法：
​   ```ar -cr lib库名.a  文件名.o ```
- ​使用：
    1. 在工作目录下运行，直接添加库路径
​		```gcc   main.c  -L 库路径  -l库名```
    2. 把自己生成的库文件拷到系统的标准库路径下，需要root权限（不推荐）
​       ```gcc  main.c  -l库名```
    3. 更改环境变量LIBRARY_PATH的值为当前路径
​       ```LIBRARY_PATH=.```
- 寻找库：
​	/lib64
​	/usr/lib64
​	/usr/local/lib
​	-L 库路径
- 优缺点：
    - 优点：对库的依赖程度低
    - 缺点：
        1. 浪费资源比较高(相对的 如果一个库只有一个程序使用)
        2. 对程序的升级不方便
#### 2. 动态库(共享库   shared library)
- 为什么会有动态库？
    > 在使用静态库时，每一次使用都会把相应的代码拷贝一份到你自己的代码中，如果你有100份代码使用这个静态库呢？是不是要把相同的一份代码拷贝100份，这样不就很浪费空间吗？所有就有了动态库。

- 动态库就是，系统中有一份这个代码，需要这份代码的，可以让自己的共享内存区映射到这份代码，从而实现对库的使用，这个最好的地方是，磁盘上只有一份代码，那个程序需要使用，在进行虚拟内存到物理内存映射时，映射到这份代码就可以了，但是这个库不能缺失，一旦缺失程序就无法正常运行。而静态库进行编译了以后就可以删除掉，因为静态库中的代码已经加入到程序中，删除它不会对程序造成影响。

1. 生成动态库
​	```gcc  -fPIC  -shared  -o  libXXX.so  XXX.c```
​   推荐加上 -fPIC(与位置无关的代码) 否则会发生一些意想不到的结果，比如你自己生成的一个库文件，在你自己电脑上运行没有问题，但是在其他人电脑上可能运行不成功。
2. 链接动态库
​	```gcc  main.c  -L动态库路径  -l动态库名字```
3. 使用动态库
    1. /lib64
​		/usr/lib64
    2. export  LD_LIBRARY_PATH=.
    3. 在/etc/ld.conf.d/xxx.conf  将文件中动态库路径写入
​		echo \`pwd`  >  /etc/ld.conf.d/xxx.confs
​		ldconifg使配置生效
- 优缺点
    - 优点：节省资源，灵活度高，更新比较方便
    - 缺点：对库的依赖程度高，运行时需要存在